/********** Firebeetle 2 - ESP32-S3 Autonomous Vehicle Control and Monitoring System **********
 * Purpose
 * Implements a smart vehicle platform using an ESP32-S3 microcontroller.
 * The system integrates live camera streaming, GPS tracking, WebSocket
 * telemetry, motor control with PID-based heading correction, IR remote
 * control, LCD feedback, LED signaling, and multiple safety indicators.
 *
 * Hardware  
 * - ESP32-S3 with OV2640 camera (powered by AXP313A PMIC)  
 * - MPU6050 gyro (I2C @0x68) for heading estimation  
 * - TinyGPS++ via UART0 (pins 43/44)  
 * - MCP23017 I/O expander (I2C @0x20) for DIR1, orange LEDs, buzzer, smoke  
 * - LCD (I2C @0x27), IR receiver (D2), motor drivers (PWM1/2 = D3/D6, DIR2 = D7)  
 * - Potentiometer (A0), vibration (A4), ultrasonic (D11/D12)  
 * Software
 * - Uses ESP-IDF / Arduino core libraries
 * - Camera driver: esp_camera
 * - Networking: WiFiMulti, WebServer, WebSockets
 * - Data encoding: ArduinoJson
 * - GPS parsing: TinyGPS++
 *
 * Reference
 *  * Version: v1.0, Th. Tsantilas, P. Savvidi
 * Date: Jan 2026
 **********/

#include "esp_camera.h"
#include "DFRobot_AXP313A.h"  // Include AXP313A library 
#include <esp32-hal-i2c.h>    // Low-level I2C to override the camera library
#include <WiFiMulti.h>
#include <ESPmDNS.h>
#include <WebServer.h>
#include <WebSocketsServer.h>
#include <ArduinoJson.h>
#include <TinyGPS++.h>
#include <Wire.h>               // I2C 
#include <Adafruit_MCP23X17.h>  // MCP23
#include <LiquidCrystal_I2C.h>  // LCD 
#include <IRremote.h>           // IR 

/* Camera pin configuration (OV2640 on ESP32-S3) */
#define CAM_PIN_PWDN    -1
#define CAM_PIN_RESET   -1
#define CAM_PIN_XCLK    45
#define CAM_PIN_SIOD    -1  //DISABLE I2C PINS  //1  // Dedicated I2C SDA for camera sensor
#define CAM_PIN_SIOC    -1                      //2  // Dedicated I2C SCL for camera sensor
#define CAM_PIN_Y9      48
#define CAM_PIN_Y8      46
#define CAM_PIN_Y7      8
#define CAM_PIN_Y6      7 //PROBLEM CONFLICT WITH MOTOR DRIVER
#define CAM_PIN_Y5      4
#define CAM_PIN_Y4      41
#define CAM_PIN_Y3      40
#define CAM_PIN_Y2      39
#define CAM_PIN_VSYNC   6
#define CAM_PIN_HREF    42
#define CAM_PIN_PCLK    5

/* GPS module configuration */
#define GPS_RX_PIN 44 //UART0
#define GPS_TX_PIN 43
#define GPS_BAUD 9600

/* Multipart stream boundary for MJPEG streaming */
#define PART_BOUNDARY "123456789000000000000987654321" 
static const char* STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

/* IR receiver configuration */
const byte IR_RECEIVE_PIN = D2;
const int DEBOUNCE_DELAY = 250;

/* Motor driver pins */
const byte DIR1_PIN =  15, DIR2_PIN = D7, PWM1_PIN = D3, PWM2_PIN = D6;

/* LED indicator pins */
const byte RED_LED_PIN = 16, WHITE_LED_PIN = 17, ORANGE_LED_PIN1 = 7, ORANGE_LED_PIN2 = 6; //orange mcp
const unsigned long BLINK_PERIOD = 660;

/* Analog sensor pins */
const byte POT_PIN = A0;        // Potentiometer for manual speed (unused in auto mode)
const int VIBRATION_PIN = A4;   // Vibration sensor input
const int SMOKE_PIN = 4;        // Smoke sensor (MCP23017 pin)
const int BUZZER_PIN = 5;       // Buzzer (MCP23017 pin)

/* LCD */
const int LCD_I2C_ADRESS = 0x27;


/* Ultrasonic sensor pins */
const byte trigPin = D11;
const byte echoPin = D12;

/* Gyro calibration and sampling */
const int MPU_I2C_ADRESS = 0x68;
const byte GYRO_SAMPLE_RATE = 10;  // ms between samples
const byte GYRO_SENSITIVITY = 131; // LSB/deg/s for Â±250dps range
const byte GYRO_XOUT_H = 0x43;   // Starting register for gyro data

/* Global state variables */
unsigned long now = millis();
unsigned long previousLcdPrintTime = 0;
int16_t gyroX, gyroY, gyroZ;
float angleX = 0.0, angleY = 0.0, angleZ = 0.0;
unsigned long previousTimeGyro = 0;
long gyroBiasX = 0, gyroBiasY = 0, gyroBiasZ = 0;
float startingAbsoluteAngleZ = 0.0;

const char* mdnsName = "esp32s3-data";
bool isStreaming = false;

/* Simulated sensor states (for testing via Serial commands) */
double latitude = 37.9838;
double longitude = 23.7275;
unsigned long lastUpdate = 0;
bool smoke = false;
bool flame = false;
bool vibration = false;
bool arrival = false;
bool departure = false;
bool busDelay = false;
bool speedLimit = false;

byte currentSpeed = 225;
float targetAngle = 0.0;

/* Blinking LED state tracking */
bool shouldRedLedsBlink = false, shouldWhiteLedsBlink = false;
bool shouldLeftOrangeLedBlink = false, shouldRightOrangeLedBlink = false;
unsigned long previousTimeRED = 0, previousTimeWHITE = 0;  
unsigned long previousTimeLeftORANGE = 0, previousTimeRightORANGE = 0;
byte previousRedLedState = 0;
byte previousWhiteLedState = 0;
byte previousLeftOrangeLedState = 0, previousRightOrangeLedState = 0;

bool manualMode = true; 
unsigned long previousIRCommandTime = 0;
byte previousCommand = 0;
unsigned long lastMcpCheck = 0;

/* PID controller parameters and state */
float pidKp = 10.0;      // ProportionalTerm gain
float pidKi = 0.5;      // Integral gain  
float pidKd = 0.05;     // Derivative gain

float pidTargetAngle = 0.0;       // Target value
float pidInput = 0.0;          // Current measured value
float pidOutput = 0.0;         // PID output (-255 to 255)
float pidError = 0.0;          // Current error
float pidIntegral = 0.0;       // Accumulated error
float pidDerivative = 0.0;     // Rate of change of error
float pidPreviousInput = 0.0;      // Previous input value
unsigned long pidPreviousTime = 0; // Last calculation time
bool pidFirstRun = true;       // Flag for first calculation

/* Global object instances */
WiFiMulti WifiMulti;
DFRobot_AXP313A Axp;
WebServer Server(80);
WiFiClient StreamingClient;
WebSocketsServer WebSocket = WebSocketsServer(81);
TinyGPSPlus Gps;
HardwareSerial GpsSerial(0); 
Adafruit_MCP23X17 Mcp;
LiquidCrystal_I2C Lcd(LCD_I2C_ADRESS, 16, 2);

/******** function handleStream  
* Purpose  
* Initiates an HTTP MJPEG stream by sending headers to the client.  
* Arguments  
* None.  
* Results  
* - Sets global isStreaming = true  
* - Sends HTTP 200 + multipart content-type header to StreamingClient  
* - Prints "Stream started" to Serial  
* Hardware  
* None.  
* Software  
* Uses global StreamingClient (WiFiClient) and STREAM_* constants.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.  
**********/
void handleStream() {
  StreamingClient = Server.client();
  
  StreamingClient.print("HTTP/1.1 200 OK\r\n");
  StreamingClient.print("Content-Type: ");
  StreamingClient.print(STREAM_CONTENT_TYPE);
  StreamingClient.print("\r\nAccess-Control-Allow-Origin: *\r\n\r\n");
  
  isStreaming = true;
  Serial.println("Stream started");
}

/******** function runStreamService  
* Purpose  
* Captures one camera frame and sends it as part of the MJPEG stream if active.  
* Arguments  
* None.  
* Results  
* - If streaming and client connected: captures JPEG frame and sends it  
* - If client disconnected: stops streaming and prints "Stream stopped"  
* - Returns early if no frame captured  
* Hardware  
* OV2640 camera module.  
* Software  
* Uses esp_camera_fb_get(), StreamingClient.write(), and esp_camera_fb_return().  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void runStreamService() {
  if (!isStreaming) return;

  if (!StreamingClient.connected()) {
    isStreaming = false;
    Serial.println("Stream stopped");
    return;
  }

  camera_fb_t * fb = esp_camera_fb_get();
  if (!fb) return;

  StreamingClient.print(STREAM_BOUNDARY);
  char part_header[64];
  sprintf(part_header, STREAM_PART, fb->len);
  StreamingClient.print(part_header);
  StreamingClient.write(fb->buf, fb->len);
  
  esp_camera_fb_return(fb);
}

/******** function broadcastData  
* Purpose  
* Broadcasts current sensor and GPS data to all WebSocket clients.  
* Arguments  
* None.  
* Results  
* - Constructs JSON with lat, lng, smoke, flame, vibration, etc.  
* - Serializes and broadcasts via WebSocket  
* - Prints JSON to Serial for debugging  
* Hardware  
* None.  
* Software  
* Uses ArduinoJson and WebSocketsServer::broadcastTXT().  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void broadcastData() {
  JsonDocument Doc; 
  Doc["lat"] = latitude;
  Doc["lng"] = longitude;
  Doc["smoke"] = smoke;
  Doc["flame"] = flame;
  Doc["vibration"] = vibration;
  Doc["arrival"] = arrival;
  Doc["departure"] = departure;
  Doc["busDelay"] = busDelay;
  Doc["speedLimit"] = speedLimit;
  Doc["uptime"] = millis() / 1000;

  String JsonString;
  serializeJson(Doc, JsonString);

  WebSocket.broadcastTXT(JsonString);
  Serial.println("Broadcasted GPS: " + JsonString);
}

/******** function displayInfo  
* Purpose  
* Prints GPS status and updates global latitude/longitude if valid.  
* Arguments  
* None.  
* Results  
* - If GPS location valid: updates global lat/lng and prints to Serial  
* - Else: prints error or satellite count  
* Hardware  
* GPS module on UART0.  
* Software  
* Uses TinyGPS++ library methods.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void displayInfo() {
  if (Gps.location.isValid()) {
    Serial.print("Latitude: ");
    Serial.print(Gps.location.lat(), 6); // 6 decimal places for accuracy
    Serial.print(" | Longitude: ");
    Serial.println(Gps.location.lng(), 6);
    latitude = Gps.location.lat();
    longitude = Gps.location.lng();
  } else {
    if (Gps.charsProcessed() < 10) {
      Serial.println("GPS Error: No data received. Check wiring/baud rate.");
    } else {
      Serial.print("GPS Status: Searching for Satellites... Satellites in view: ");
      Serial.println(Gps.satellites.value());
    }
  }
}

/******** function resetPID  
* Purpose  
* Resets PID controller state to prevent windup during mode transitions.  
* Arguments  
* None.  
* Results  
* - Clears integral term  
* - Sets pidPreviousInput = current input  
* - Marks next calculation as first run  
* - Updates pidPreviousTime to current millis()  
* Hardware  
* None.  
* Software  
* Modifies global PID state variables.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void resetPID() {
  pidIntegral = 0.0;
  pidPreviousInput = pidInput;
  pidFirstRun = true;
  pidPreviousTime = millis();
}

/******** function pidCorrection  
* Purpose  
* Computes PID output for differential steering based on heading error.  
* Arguments  
* targetAngle: Desired heading relative to start (float, degrees)  
* currentAngle: Absolute gyro Z angle (float, degrees)  
* baseSpeed: Base motor speed (byte, 0-255)  
* Results  
* - Calculates PID output with anti-windup  
* - Sets left/right motor speeds via analogWrite()  
* - Constrains output to [-255, 255]  
* Hardware  
* Motor drivers on PWM1_PIN, PWM2_PIN.  
* Software  
* Uses global PID parameters and state.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026. 
**********/
void pidCorrection(float targetAngle, float currentAngle, byte baseSpeed) {
  
  float relativeAngle = currentAngle - startingAbsoluteAngleZ;

  // Update PID state
  pidTargetAngle = targetAngle;
  pidInput = relativeAngle;
  
  float dt = (now - pidPreviousTime) / 1000.0; // Convert to seconds
  
  if (dt >= 0.001) { // At least 1ms has passed
    pidError = pidTargetAngle - pidInput;
    
    // Calculate integral with anti-windup
    pidIntegral += pidError * dt;
    if (pidIntegral > 100.0) pidIntegral = 100.0;
    if (pidIntegral < -100.0) pidIntegral = -100.0;
    
    // Calculate derivative
    if (!pidFirstRun) {
      pidDerivative = (pidInput - pidPreviousInput) / dt;
    } else {
      pidDerivative = 0.0;
      pidFirstRun = false;
    }
     
    // Calculate PID output
    float proportionalTerm = pidKp * pidError;
    float integralTerm = pidKi * pidIntegral;
    float derivativeTerm = pidKd * pidDerivative;
    
    pidOutput = proportionalTerm + integralTerm - derivativeTerm; // Negative derivative term because of inputting process variable instead of error
    
    // Constrain output to valid range
    if (pidOutput > 255.0) pidOutput = 255.0;
    else if (pidOutput < -255.0) pidOutput = -255.0;
    
    // Store values for next calculation
    pidPreviousInput = pidInput;
    pidPreviousTime = now;
  }

  // Calculate motor speeds with PID output
  byte rightMotor = constrain(baseSpeed + pidOutput, 0, 255);
  byte leftMotor  = constrain(baseSpeed - pidOutput, 0, 255);

  analogWrite(PWM2_PIN, rightMotor);
  analogWrite(PWM1_PIN, leftMotor);
}

/******** function gyroBegin  
* Purpose  
* Initializes MPU6050 gyro by waking it from sleep mode.  
* Arguments  
* None.  
* Results  
* - Writes 0x00 to MPU6050 register 0x6B (PWR_MGMT_1)  
* Hardware  
* MPU6050 on I2C @0x68.  
* Software  
* Uses Wire library for I2C transaction.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.  
**********/
void gyroBegin() {
  Wire.beginTransmission(MPU_I2C_ADRESS);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);
}

/******** function readGyro  
* Purpose  
* Reads and processes gyro data at fixed intervals, updating angleZ.  
* Arguments  
* None.  
* Results  
* - Reads raw gyro X/Y/Z values  
* - Applies bias correction and sensitivity scaling  
* - Integrates to update angleZ (yaw) using trapezoidal rule  
* Hardware  
* MPU6050 on I2C @0x68.  
* Software  
* Uses global gyroBias* and GYRO_* constants.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.   
**********/
void readGyro() {
  if (now - previousTimeGyro >= GYRO_SAMPLE_RATE) {
    Wire.beginTransmission(MPU_I2C_ADRESS);
    Wire.write(GYRO_XOUT_H);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_I2C_ADRESS, 6, true);

    gyroX = Wire.read() << 8 | Wire.read(); 
    gyroY = Wire.read() << 8 | Wire.read();
    gyroZ = Wire.read() << 8 | Wire.read();

    gyroX -= gyroBiasX;
    gyroY -= gyroBiasY;
    gyroZ -= gyroBiasZ;

    gyroX /= GYRO_SENSITIVITY;
    gyroY /= GYRO_SENSITIVITY;
    gyroZ /= GYRO_SENSITIVITY;

    float dt = (now - previousTimeGyro) / 1000.0;
    angleX += gyroX * dt;
    angleY += gyroY * dt;
    angleZ += gyroZ * dt;

    previousTimeGyro = now;
  }
}

/******** function calibrateGyro  
* Purpose  
* Computes average gyro bias by sampling 100 readings at rest.  
* Arguments  
* None.  
* Results  
* - Updates global gyroBiasX/Y/Z with average offset  
* - Delays GYRO_SAMPLE_RATE ms between samples  
* Hardware  
* MPU6050 must be stationary during calibration.  
* Software  
* Uses direct I2C reads without TinyWire.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.   
**********/
void calibrateGyro() {
  long gyroSumX = 0, gyroSumY = 0, gyroSumZ = 0;
  const int samples = 100;  

  for (int gyroReadings = 0; gyroReadings < samples; gyroReadings++) {
    Wire.beginTransmission(MPU_I2C_ADRESS);
    Wire.write(GYRO_XOUT_H);
    Wire.endTransmission(false);
    Wire.requestFrom(MPU_I2C_ADRESS, 6, true);

    gyroX = Wire.read() << 8 | Wire.read(); 
    gyroY = Wire.read() << 8 | Wire.read();
    gyroZ = Wire.read() << 8 | Wire.read();

    gyroSumX += gyroX;
    gyroSumY += gyroY;
    gyroSumZ += gyroZ;
    delay(GYRO_SAMPLE_RATE); 
  }

  gyroBiasX = gyroSumX / samples;
  gyroBiasY = gyroSumY / samples;
  gyroBiasZ = gyroSumZ / samples;
}

/******** function forward  
* Purpose  
* Drives both motors forward at specified speed and sets LED indicators.  
* Arguments  
* speed: Motor speed (byte, 0-255)  
* Results  
* - Sets DIR1_PIN (MCP) and DIR2_PIN (GPIO) LOW  
* - Sets PWM1/PWM2 to speed  
* - Turns off all blinking LEDs (sets solid OFF)  
* Hardware  
* Motor driver H-bridge control pins.  
* Software  
* Uses Mcp.digitalWrite() and digitalWrite().  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void forward(byte speed) {

  Mcp.digitalWrite(DIR1_PIN, LOW);
  digitalWrite(DIR2_PIN, LOW);
  analogWrite(PWM1_PIN, speed);
  analogWrite(PWM2_PIN, speed);
  
  shouldRedLedsBlink = false;
  digitalWrite(RED_LED_PIN, LOW);
  shouldWhiteLedsBlink = false;
  digitalWrite(WHITE_LED_PIN, LOW);
  shouldLeftOrangeLedBlink = false;
  Mcp.digitalWrite(ORANGE_LED_PIN1, LOW);
  shouldRightOrangeLedBlink = false;
  Mcp.digitalWrite(ORANGE_LED_PIN2, LOW);

  //shouldBuzzerBuzz  = false;
  //Mcp.digitalWrite(BUZZER_PIN, LOW);
}

/******** function backward  
* Purpose  
* Drives both motors backward and activates white LED.  
* Arguments  
* speed: Motor speed (byte, 0-255)  
* Results  
* - Sets DIR1_PIN and DIR2_PIN HIGH  
* - Sets PWM1/PWM2 to speed  
* - Turns on white LED (solid ON, not blinking)  
* Hardware  
* Motor driver and white LED.  
* Software  
* None.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026. 
**********/
void backward(byte speed) {

  Mcp.digitalWrite(DIR1_PIN, HIGH);
  digitalWrite(DIR2_PIN, HIGH);
  analogWrite(PWM1_PIN, speed);
  analogWrite(PWM2_PIN, speed);

  shouldRedLedsBlink = false;
  digitalWrite(RED_LED_PIN, LOW);
  shouldWhiteLedsBlink = true;
  digitalWrite(WHITE_LED_PIN, HIGH);
  shouldLeftOrangeLedBlink = false;
  Mcp.digitalWrite(ORANGE_LED_PIN1, LOW);
  shouldRightOrangeLedBlink = false;
  Mcp.digitalWrite(ORANGE_LED_PIN2, LOW);

}

/******** function turnLeft  
* Purpose  
* Turns vehicle left by reversing left motor and activating left orange LED.  
* Arguments  
* speed: Motor speed (byte, 0-255)  
* Results  
* - Sets DIR1_PIN HIGH, DIR2_PIN LOW  
* - Sets PWM1/PWM2 to speed  
* - Blinks left orange LED  
* Hardware  
* Motor driver and MCP-controlled orange LED.  
* Software  
* None.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026. 
**********/
 void turnLeft(byte speed) {

  Mcp.digitalWrite(DIR1_PIN, HIGH);
  digitalWrite(DIR2_PIN, LOW);
  analogWrite(PWM1_PIN, speed);
  analogWrite(PWM2_PIN, speed);
  
  shouldRedLedsBlink = false;
  digitalWrite(RED_LED_PIN, LOW);
  shouldWhiteLedsBlink = false;
  digitalWrite(WHITE_LED_PIN, LOW);
  shouldLeftOrangeLedBlink = true;
  Mcp.digitalWrite(ORANGE_LED_PIN1, HIGH);
  shouldRightOrangeLedBlink = false;
  Mcp.digitalWrite(ORANGE_LED_PIN2, LOW);

} 

/******** function turnRight  
* Purpose  
* Turns vehicle right by reversing right motor and activating right orange LED.  
* Arguments  
* speed: Motor speed (byte, 0-255)  
* Results  
* - Sets DIR1_PIN LOW, DIR2_PIN HIGH  
* - Sets PWM1/PWM2 to speed  
* - Blinks right orange LED  
* Hardware  
* Motor driver and MCP-controlled orange LED.  
* Software  
* None.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026. 
**********/
void turnRight(byte speed) {

  Mcp.digitalWrite(DIR1_PIN, LOW);
  digitalWrite(DIR2_PIN, HIGH);
  analogWrite(PWM1_PIN, speed);
  analogWrite(PWM2_PIN, speed);
  
  shouldRedLedsBlink = false;
  digitalWrite(RED_LED_PIN, LOW);
  shouldWhiteLedsBlink = false;
  digitalWrite(WHITE_LED_PIN, LOW);
  shouldLeftOrangeLedBlink = false;
  Mcp.digitalWrite(ORANGE_LED_PIN1, LOW);
  shouldRightOrangeLedBlink = true;
  Mcp.digitalWrite(ORANGE_LED_PIN2, HIGH);

}

/******** function stop  
* Purpose  
* Stops motors and blinks red LED to indicate halt.  
* Arguments  
* None.  
* Results  
* - Sets PWM1/PWM2 to 0  
* - Enables red LED blinking  
* - Turns off other LEDs  
* Hardware  
* Motors and red LED.  
* Software  
* None.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.  
**********/
void stop() {

  analogWrite(PWM1_PIN, 0);
  analogWrite(PWM2_PIN, 0);
  
  shouldRedLedsBlink = true;
  digitalWrite(RED_LED_PIN, HIGH);
  shouldWhiteLedsBlink = false;
  digitalWrite(WHITE_LED_PIN, LOW);
  shouldLeftOrangeLedBlink = false;
  Mcp.digitalWrite(ORANGE_LED_PIN1, LOW);
  shouldRightOrangeLedBlink = false;
  Mcp.digitalWrite(ORANGE_LED_PIN2, LOW);

}

/******** function manual_mode  
* Purpose  
* Switches vehicle to manual IR control mode.  
* Arguments  
* None.  
* Results  
* - Sets global manualMode = true  
* - Calls stop()  
* - Prints "MANUAL MODE" to Serial  
* Hardware  
* None.  
* Software  
* None.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.  
**********/
void manual_mode() {
  manualMode = true;
  stop(); 
  Serial.println("MANUAL MODE");
}

/******** function automaticMode  
* Purpose  
* Switches vehicle to automatic PID steering mode.  
* Arguments  
* None.  
* Results  
* - Sets manualMode = false  
* - Stops motors and disables all LED blinking  
* - Sets startingAbsoluteAngleZ = current angleZ  
* - Resets targetAngle and PID state  
* - Prints "AUTOMATIC MODE" to Serial  
* Hardware  
* None.  
* Software  
* Calls resetPID().  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void automaticMode() {
  manualMode = false;
  stop();
  shouldRedLedsBlink = false;
  shouldWhiteLedsBlink = false;
  shouldLeftOrangeLedBlink = false;
  shouldRightOrangeLedBlink = false;
  digitalWrite(RED_LED_PIN, LOW);
  digitalWrite(WHITE_LED_PIN, LOW);
  Mcp.digitalWrite(ORANGE_LED_PIN1, LOW);
  Mcp.digitalWrite(ORANGE_LED_PIN2, LOW);

  
  startingAbsoluteAngleZ = angleZ;  // Store the current angle as the reference
  targetAngle = 0.0;  // Reset current heading as reference point
  resetPID();  // Clear accumulated errors
  Serial.println("AUTOMATIC MODE");

}

/******** function checkRedLeds  
* Purpose  
* Toggles red LED state if blinking is enabled and period elapsed.  
* Arguments  
* None.  
* Results  
* - Updates RED_LED_PIN state based on BLINK_PERIOD  
* - Updates previousTimeRED and previousRedLedState  
* Hardware  
* Red LED on GPIO 16.  
* Software  
* Uses global now and blink flags.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void checkRedLeds() {
  if (now - previousTimeRED >= BLINK_PERIOD && shouldRedLedsBlink) {
    previousRedLedState = !previousRedLedState;
    digitalWrite(RED_LED_PIN, previousRedLedState);
    previousTimeRED = now;
  }
}

/******** function checkWhiteLeds  
* Purpose  
* Toggles white LED state if blinking is enabled and period elapsed.  
* Arguments  
* None.  
* Results  
* - Updates WHITE_LED_PIN state based on BLINK_PERIOD  
* - Updates previousTimeWHITE and previousWhiteLedState  
* Hardware  
* White LED on GPIO 17.  
* Software  
* Uses global now and blink flags.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void checkWhiteLeds() {
  if (now - previousTimeWHITE >= BLINK_PERIOD && shouldWhiteLedsBlink) {
    previousWhiteLedState = !previousWhiteLedState;
    digitalWrite(WHITE_LED_PIN, previousWhiteLedState);
    previousTimeWHITE = now;
  }
}

/******** function checkLeftOrangeLed  
* Purpose  
* Toggles left orange LED state if blinking is enabled and period elapsed.  
* Arguments  
* None.  
* Results  
* - Updates MCP pin ORANGE_LED_PIN1 state  
* - Updates previousTimeLeftORANGE and state  
* Hardware  
* Orange LED on MCP23017 pin 7.  
* Software  
* Uses Mcp.digitalWrite().  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.  
**********/
void checkLeftOrangeLed() {
  if (now - previousTimeLeftORANGE >= BLINK_PERIOD && shouldLeftOrangeLedBlink) {
    previousLeftOrangeLedState = !previousLeftOrangeLedState;
    Mcp.digitalWrite(ORANGE_LED_PIN1, previousLeftOrangeLedState);
    previousTimeLeftORANGE = now;
  }
}

/******** function checkRightOrangeLed  
* Purpose  
* Toggles right orange LED state if blinking is enabled and period elapsed.  
* Arguments  
* None.  
* Results  
* - Updates MCP pin ORANGE_LED_PIN2 state  
* - Updates previousTimeRightORANGE and state  
* Hardware  
* Orange LED on MCP23017 pin 6.  
* Software  
* Uses Mcp.digitalWrite().  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.  
**********/
void checkRightOrangeLed() {
  if (now - previousTimeRightORANGE >= BLINK_PERIOD && shouldRightOrangeLedBlink) {
    previousRightOrangeLedState = !previousRightOrangeLedState;
    Mcp.digitalWrite(ORANGE_LED_PIN2, previousRightOrangeLedState);
    previousTimeRightORANGE = now;
  }
}

/******** function handleIRcommunication  
* Purpose  
* Decodes IR commands and executes vehicle actions or mode changes.  
* Arguments  
* None.  
* Results  
* - Ignores repeats and debounces rapid presses  
* - Executes movement, mode switch, or target angle change based on command  
* - Updates currentSpeed on volume buttons  
* Hardware  
* IR receiver on D2.  
* Software  
* Uses IRremote library. Command mapping defined in switch-case.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.    
**********/
void handleIRcommunication() {
  if (IrReceiver.decode()) {
    // Ignore repeated signal
    if (IrReceiver.decodedIRData.flags & IRDATA_FLAGS_IS_REPEAT) {
      IrReceiver.resume();
      return;
    }
    
    if (now - previousIRCommandTime < DEBOUNCE_DELAY &&
      IrReceiver.decodedIRData.command == previousCommand) {
      IrReceiver.resume();
      return;
    }

    previousIRCommandTime = now;
    previousCommand = IrReceiver.decodedIRData.command;

    switch (IrReceiver.decodedIRData.command) { 
      case 24:  if(manualMode) forward(currentSpeed);   else {
        Mcp.digitalWrite(DIR1_PIN, HIGH);
        digitalWrite(DIR2_PIN, HIGH);
        startingAbsoluteAngleZ = angleZ; 
        targetAngle = 0.0; 

        }
        break; 
      case 82:  backward(currentSpeed); break;
      case 8:   if(manualMode) turnLeft(currentSpeed); else {
        startingAbsoluteAngleZ = angleZ; 
        targetAngle = 90;  

        }
        break;
      case 90:  if(manualMode) turnRight(currentSpeed); else {
        startingAbsoluteAngleZ = angleZ; 
        targetAngle = -90; 
        }
        break;
      case 28:  stop();                    break;
      case 69:  manual_mode();             break;
      case 71:  automaticMode();          break;

      
      case 12:  targetAngle = 45;          break;
      case 94:  targetAngle = -45;         break;
      case 66:  targetAngle = -45;         break;
      case 74:  targetAngle = 45;          break;

      case 21:
        if(currentSpeed + 10 <= 255) currentSpeed += 10;
        analogWrite(PWM1_PIN, currentSpeed);
        analogWrite(PWM2_PIN, currentSpeed);
        break;

      case 7:
        if(currentSpeed - 10 >= 70) currentSpeed -= 10;
        analogWrite(PWM1_PIN, currentSpeed);
        analogWrite(PWM2_PIN, currentSpeed);
        break;

      default:
        break;
    }
  }
  IrReceiver.resume();

}

/******** function setup  
* Purpose  
* Initializes all hardware peripherals, connects to WiFi, and starts services.  
* Arguments  
* None.  
* Results  
* - Configures Serial, GPS, I2C, LCD, MCP, IR, motors, LEDs, ultrasonic  
* - Connects to WiFi using fallback networks  
* - Starts mDNS and initializes AXP313A for camera power  
* - Configures and initializes OV2640 camera  
* - Sets up web server routes and WebSocket  
* Hardware  
* All connected sensors and actuators.  
* Software  
* Uses all included libraries. Critical: camera init AFTER other I2C devices.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026.   
**********/
void setup() {
  Serial.begin(115200);

  GpsSerial.begin(GPS_BAUD, SERIAL_8N1, GPS_RX_PIN, GPS_TX_PIN);
  Wire.begin();
  gyroBegin();
  calibrateGyro();
  Lcd.init();
  Lcd.backlight();
  Lcd.clear();
  if (!Mcp.begin_I2C()) {
    Serial.println(" Mcp Error.");
  }

  IrReceiver.begin(IR_RECEIVE_PIN, DISABLE_LED_FEEDBACK);

  Mcp.pinMode(DIR1_PIN, OUTPUT);
  pinMode(DIR2_PIN, OUTPUT);
  pinMode(PWM1_PIN, OUTPUT);
  pinMode(PWM2_PIN, OUTPUT);

  pinMode(RED_LED_PIN, OUTPUT);
  pinMode(WHITE_LED_PIN, OUTPUT);
  Mcp.pinMode(ORANGE_LED_PIN1, OUTPUT);
  Mcp.pinMode(ORANGE_LED_PIN2, OUTPUT);

  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);

  WifiMulti.addAP("COSMOTE-536092-2.4GHz", "vlhelen2003");
  WifiMulti.addAP("PasadesOnly", "AnythingGoes");  // Fallback network
  WifiMulti.addAP("realme C33", "ibanezfender");  // Another fallback

  Serial.println("Connecting to WiFi...");
  while (WifiMulti.run() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi Connected!");

  if (MDNS.begin(mdnsName)) {
    Serial.println("mDNS started: " + String(mdnsName) + ".local");
    MDNS.addService("ws", "tcp", 81);
  }

  while(Axp.begin() != 0){
    Serial.println("init error");
    delay(1000);
  }
  Axp.enableCameraPower(Axp.eOV2640);

  
  camera_config_t Config;
  Config.ledc_channel = LEDC_CHANNEL_0;
  Config.ledc_timer = LEDC_TIMER_0;
  Config.pin_d0 = CAM_PIN_Y2;
  Config.pin_d1 = CAM_PIN_Y3;
  Config.pin_d2 = CAM_PIN_Y4;
  Config.pin_d3 = CAM_PIN_Y5;
  Config.pin_d4 = CAM_PIN_Y6;
  Config.pin_d5 = CAM_PIN_Y7;
  Config.pin_d6 = CAM_PIN_Y8;
  Config.pin_d7 = CAM_PIN_Y9;
  Config.pin_xclk = CAM_PIN_XCLK;
  Config.pin_pclk = CAM_PIN_PCLK;
  Config.pin_vsync = CAM_PIN_VSYNC;
  Config.pin_href = CAM_PIN_HREF;
  Config.sccb_i2c_port = 0; //IMPORTANT TO LEAVE I2C FOR OTHER SENSORS
  Config.pin_sscb_sda = CAM_PIN_SIOD; 
  Config.pin_sscb_scl = CAM_PIN_SIOC; 
  Config.pin_pwdn = CAM_PIN_PWDN;
  Config.pin_reset = CAM_PIN_RESET;
  Config.xclk_freq_hz = 20000000; // 20MHz
  Config.pixel_format = PIXFORMAT_JPEG; 
  Config.frame_size = FRAMESIZE_VGA; // 640x480 resolution
  Config.jpeg_quality = 12;
  Config.fb_count = 2; // Number of frame buffers
  Config.fb_location = CAMERA_FB_IN_PSRAM; // Use PSRAM 
  Config.grab_mode = CAMERA_GRAB_LATEST; 

 
  esp_err_t err = esp_camera_init(&Config);
  if (err != ESP_OK) {
    Serial.printf("Camera initialization failed with error 0x%x\n", err);
    Serial.println("Check AXP313A power settings and wiring.");
    return;
  }

  Serial.println("Camera initialized successfully for car vision system.");

 
  sensor_t* s = esp_camera_sensor_get();
  s->set_brightness(s, 0);     // -2 to 2
  s->set_contrast(s, 2);       // -2 to 2
  s->set_saturation(s, 0);     // -2 to 2
  s->set_special_effect(s, 0); // 0 to 6 (0 - No Effect, 1 - Negative, 2 - Grayscale, 3 - Red Tint, 4 - Green Tint, 5 - Blue Tint, 6 - Sepia)
  s->set_whitebal(s, 0);       // 0 = disable , 1 = enable
  s->set_awb_gain(s, 0);       // 0 = disable , 1 = enable
  s->set_wb_mode(s, 0);        // 0 to 4 - if awb_gain enabled (0 - Auto, 1 - Sunny, 2 - Cloudy, 3 - Office, 4 - Home)
  s->set_exposure_ctrl(s, 0);  // 0 = disable , 1 = enable
  s->set_aec2(s, 0);           // 0 = disable , 1 = enable
  s->set_ae_level(s, 0);       // -2 to 2
  s->set_aec_value(s, 1200);    // 0 to 1200
  s->set_gain_ctrl(s, 0);      // 0 = disable , 1 = enable
  s->set_agc_gain(s, 1);       // 0 to 30
  s->set_gainceiling(s, (gainceiling_t)0);  // 0 to 6
  s->set_bpc(s, 0);            // 0 = disable , 1 = enable
  s->set_wpc(s, 0);            // 0 = disable , 1 = enable
  s->set_raw_gma(s, 0);        // 0 = disable , 1 = enable
  s->set_lenc(s, 0);           // 0 = disable , 1 = enable
  s->set_quality(s, 12);
  s->set_hmirror(s, 0);        // 0 = disable , 1 = enable
  s->set_vflip(s, 0);          // 0 = disable , 1 = enable
  s->set_dcw(s, 1);            // 0 = disable , 1 = enable
  s->set_colorbar(s, 0);       // 0 = disable , 1 = enable

  Server.on("/stream", HTTP_GET, handleStream);
  Server.begin();

  WebSocket.begin();
}

/******** function loop  
* Purpose  
* Main control loop: handles networking, sensors, user input, and actuation.  
* Arguments  
* None.  
* Results  
* - Services HTTP and WebSocket clients  
* - Processes IR commands  
* - Handles Serial debug commands (e.g., "smoke", "reset")  
* - Broadcasts sensor data every 2 seconds  
* - Reinitializes MCP if disconnected  
* - Updates LED blink states  
* - Feeds GPS data to TinyGPS++  
* - Reads gyro and runs PID if in automatic mode  
* - Updates LCD with target and current angles  
* Hardware  
* All peripherals.  
* Software  
* Orchestrates all subsystems at ~10ms loop rate.  
* Reference  
* v1.0, Th. Tsantilas, P. Savvidi, Jan. 2026. 
**********/
void loop() {
  now = millis();
  Server.handleClient(); 
  runStreamService();    
  
  WebSocket.loop();
    
  handleIRcommunication();

  if (Serial.available() > 0) {
    String command = Serial.readStringUntil('\n');
    command.trim(); 
    if (command == "update") {
      latitude += (random(-100, 100) / 1000.0);
      longitude += (random(-100, 100) / 1000.0);
      Serial.printf("New Coordinates: Lat: %f, Lng: %f\n", latitude, longitude);
      broadcastData(); 
    } 
    else if (command == "smoke") {
      smoke = true;
      Serial.println("Smoke Detected!");
      broadcastData(); 
    } 
    else if (command == "flame") {
      flame = true;
      Serial.println("Fire Detected!");
      broadcastData();
    } 
    else if (command == "vibration") {
      vibration = true;
      Serial.println("Vibrations Detected!");
      broadcastData();
    } 
    else if (command == "arrival") {
      arrival = true;
      Serial.println("Arrived!");
      broadcastData();
    } 
    else if (command == "departure") {
      departure = true;
      Serial.println("Departure!");
      broadcastData();
    } 
    else if (command == "busDelay") {
      busDelay = true; 
      Serial.println("Delays!");
      broadcastData();
    } 
    else if (command == "speedLimit") {
      speedLimit = true; 
      Serial.println("Speed Limit!");
      broadcastData();
    } 
    else if (command == "reset") {
      smoke = false;
      flame = false;
      vibration = false;
      arrival = false;
      departure = false;
      busDelay = false;
      speedLimit = false;
      Serial.println("Reset!");
      broadcastData();
    }
  }

  //send to web socket every 2 seconds
  if (millis() - lastUpdate > 2000) {
    lastUpdate = millis();
    broadcastData();
  }

  if (millis() - lastMcpCheck > 5000) {
    lastMcpCheck = millis();
    
    Wire.beginTransmission(0x20); //MCP address
    if (Wire.endTransmission() != 0) {
      Serial.println("MCP Disconnected! Re-initializing...");
      Mcp.begin_I2C(); 
     
      Mcp.pinMode(DIR1_PIN, OUTPUT);
      Mcp.pinMode(ORANGE_LED_PIN1, OUTPUT);
      Mcp.pinMode(ORANGE_LED_PIN2, OUTPUT);
      // Re-apply pinMode settings 
    }
  }
  
  checkRedLeds();
  checkWhiteLeds();
  checkLeftOrangeLed();
  checkRightOrangeLed();

  // Feed characters from GPS to TinyGPS++
  while (GpsSerial.available() > 0) {
    if (Gps.encode(GpsSerial.read())) {
      displayInfo();
    }
  }
  
  readGyro();
  if (!manualMode){
    pidCorrection(targetAngle, angleZ, currentSpeed);
  }

  if (now - previousLcdPrintTime > 100) {
    char targetAngleStr[9]; // Need space for 8 chars + null terminator
    char angleZStr[9];

    sprintf(targetAngleStr, "%5.2f", targetAngle); 
    sprintf(angleZStr, "%5.2f", angleZ);           

    Lcd.setCursor(0, 0);
    Lcd.print(targetAngleStr);
    Lcd.setCursor(0, 1);
    Lcd.print(angleZStr);

    previousLcdPrintTime = now;
  }
  
}



